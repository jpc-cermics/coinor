-nsp->// -*- Mode: scilab -*-
-nsp->// Copyright (C) 2017-2017 Aurelien Alfonsi, Jean-Philippe Chancelier Enpc/Cermics
-nsp->//
-nsp->// This program is free software; you can redistribute it and/or modify
-nsp->// it under the terms of the GNU General Public License as published by
-nsp->// the Free Software Foundation; either version 2 of the License, or
-nsp->// (at your option) any later version.
-nsp->//
-nsp->// This program is distributed in the hope that it will be useful,
-nsp->// but WITHOUT ANY WARRANTY; without even the implied warranty of
-nsp->// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-nsp->// GNU General Public License for more details.
-nsp->//
-nsp->// You should have received a copy of the GNU General Public License
-nsp->// along with this program; if not, write to the Free Software
-nsp->// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-nsp->//
-nsp->// a test for a quadratic problem for which we have
-nsp->// an other way to compute the solution
-nsp->function [rp,rw]=convex_hull_psi(p_m,w_m,p_n,w_n)
==>  //#calcule la conction psi enveloppe convexe de int_0^q F^{-1}_m(u)-F^{-1}(u)du
==>  L=[ ]
==>  VAL=[]
==>  L.concatr[0.]
==>  VAL.concatr[0.]
==>  s_m=cumsum(w_m)
==>  s_n=cumsum(w_n)
==>  l_m=length(w_m)
==>  l_n=length(w_n)
==>  i_m=1
==>  i_n=1
==>  ta=0.
==>  val=0.
==>  while (i_m <= l_m)&(i_n <= l_n) do
==>    t=min(s_m(i_m),s_n(i_n))
==>    val=val+(t-ta)*(p_m(i_m)-p_n(i_n))
==>    while length(L)>1 && (VAL($)-VAL($-1))/(L($)-L($-1))>=(val-VAL($))/(t-L($)) do        
==>      L($)=[]
==>      VAL($)=[]
==>    end
==>    L.concatr[t];
==>    VAL.concatr[val];
==>    ta=t
==>    if t==s_m(i_m) then
==>      i_m=i_m+1
==>    end
==>    if t==s_n(i_n) then
==>      i_n=i_n+1
==>    end
==>  end
==>  [rp,rw]=(L,VAL);
==>endfunction;
-nsp->function [rp,rw]=curlywedge(p_m,w_m,p_n,w_n)
==>  [L,VAL]=convex_hull_psi(p_m,w_m,p_n,w_n)   
==>  DL= L ; 
==>  DVAL= VAL;
==>  // DL=DL[1:]-DL[:-1]
==>  DL=DL(2:$) -DL(1:$-1);
==>  DVAL=(DVAL(2:$) -DVAL(1:$-1))./ DL
==>  i_m=1
==>  l_m=length(w_m)
==>  i_L=1
==>  l_L=length(DL)
==>  s_m=cumsum(w_m)
==>  s_L=cumsum(DL)
==>  ta=0.
==>  L=[]
==>  VAL=[]
==>  while (i_m<=l_m)&(i_L<=l_L) do
==>    t=min(s_m(i_m),s_L(i_L))
==>    VAL.concatr[p_m(i_m)-DVAL(i_L)]
==>    L.concatr[t-ta]
==>    if t==s_m(i_m) then
==>      i_m=i_m+1
==>    end
==>    if t==s_L(i_L) then
==>      i_L=i_L+1
==>    end
==>    ta=t
==>  end
==>  [rp,rw]=(VAL,L);
==>endfunction
curlywedge	=		pl (file='alfonsi.tst')
  [32mfunction[0m [rp,rw]=[34mcurlywedge[0m(p_m,w_m,p_n,w_n)
    [L,VAL]=convex_hull_psi(p_m,w_m,p_n,w_n)
    DL=L[30m;[0m
    DVAL=VAL[30m;[0m
    [34m// DL=DL[1:]-DL[:-1][0m
    DL=DL([35m2[0m[30m:[0m$)[30m-[0mDL([35m1[0m[30m:[0m$[30m-[0m[35m1[0m)[30m;[0m
    DVAL=(DVAL([35m2[0m[30m:[0m$)[30m-[0mDVAL([35m1[0m[30m:[0m$[30m-[0m[35m1[0m))[30m ./[0mDL
    i_m=[35m1[0m
    l_m=length(w_m)
    i_L=[35m1[0m
    l_L=length(DL)
    s_m=cumsum(w_m)
    s_L=cumsum(DL)
    ta=[35m0. [0m
    L=[]
    VAL=[]
    [32mwhile[0m (i_m[30m <= [0ml_m)[30m & [0m(i_L[30m <= [0ml_L) [32mdo[0m
      t=min(s_m(i_m),s_L(i_L))
      VAL.concatr[p_m(i_m)[30m-[0mDVAL(i_L)]
      L.concatr[t[30m-[0mta]
      [32mif[0m         t[30m==[0ms_m(i_m) [32mthen[0m
        i_m=i_m[30m+[0m[35m1[0m
      [32mend[0m
      [32mif[0m         t[30m==[0ms_L(i_L) [32mthen[0m
        i_L=i_L[30m+[0m[35m1[0m
      [32mend[0m
      ta=t
    [32mend[0m
    [rp,rw]=(VAL,L)[30m;[0m
  [32mendfunction[0m
-nsp->function res=wasserstein(p_m,w_m,p_n,w_n,rho)    
==>  i_n=1; l_n=length(w_n);
==>  i_m=1; l_m=length(w_m)
==>  s_n=cumsum(w_n);
==>  s_m=cumsum(w_m);
==>  ta=0.;
==>  wass=0.;
==>  while (i_m < l_m)&&(i_n < l_n) do
==>    t=min(s_m(i_m),s_n(i_n))
==>    wass=wass+(t-ta)*abs(p_m(i_m)-p_n(i_n))^rho
==>    if t==s_n(i_n) then
==>      i_n=i_n+1
==>    end
==>    if t==s_m(i_m) then 
==>      i_m=i_m+1
==>    end
==>    ta=t;
==>  end
==>  res= wass^(1.0/rho)   
==>endfunction
wasserstein	=		pl (file='alfonsi.tst')
  [32mfunction[0m res=[34mwasserstein[0m(p_m,w_m,p_n,w_n,rho)
    i_n=[35m1[0m[30m;[0ml_n=length(w_n)[30m;[0m
    i_m=[35m1[0m[30m;[0ml_m=length(w_m)
    s_n=cumsum(w_n)[30m;[0m
    s_m=cumsum(w_m)[30m;[0m
    ta=[35m0. [0m[30m;[0m
    wass=[35m0. [0m[30m;[0m
    [32mwhile[0m (i_m[30m < [0ml_m)[30m && [0m(i_n[30m < [0ml_n) [32mdo[0m
      t=min(s_m(i_m),s_n(i_n))
      wass=wass[30m+[0m(t[30m-[0mta)[30m*[0mabs(p_m(i_m)[30m-[0mp_n(i_n))[30m^[0mrho
      [32mif[0m         t[30m==[0ms_n(i_n) [32mthen[0m
        i_n=i_n[30m+[0m[35m1[0m
      [32mend[0m
      [32mif[0m         t[30m==[0ms_m(i_m) [32mthen[0m
        i_m=i_m[30m+[0m[35m1[0m
      [32mend[0m
      ta=t[30m;[0m
    [32mend[0m
    res=wass[30m^[0m([35m1.0[0m[30m/[0mrho)
  [32mendfunction[0m
-nsp->function [p,m]=filter(p_m,w_m)
==>  // remove points with very low proba.
==>  // we assume that p_m and w_m must have the same size
==>  I=find(w_m> 1e-12)
==>  p=p_m(I);
==>  m=w_m(I);
==>endfunction
filter	=		pl (file='alfonsi.tst')
  [32mfunction[0m [p,m]=[34mfilter[0m(p_m,w_m)
    [34m// remove points with very low proba.[0m
    [34m// we assume that p_m and w_m must have the same size[0m
    I=find(w_m[30m > [0m[35m1E-12[0m)
    p=p_m(I)[30m;[0m
    m=w_m(I)[30m;[0m
  [32mendfunction[0m
-nsp->// Create a clp quadratic problem
-nsp->N=10
N	=		r (1x1)

 |  10 |
-nsp->N2=N*N;
-nsp->X=2*rand(1,N)-1;
-nsp->Y=4*rand(1,N)-2;
-nsp->p=zeros(1,N2);
-nsp->M=zeros(N2,N2);
-nsp->C=zeros(2*N,N2);
-nsp->b=ones(2*N,1); 
-nsp->me=2*N;
-nsp->for i=1:N,
==>  for j=1:N,
==>    p((i-1)*N+j)=-X(i)*Y(j);
==>    C(i,(i-1)*N+j)=1;
==>    C(N+j,(i-1)*N+j)=1;
==>    for k=1:N,
==>      M((i-1)*N+j,(i-1)*N+k)=Y(j)*Y(k);
==>    end;
==>  end;
==>end;
-nsp->// solve the  quadratic problem
-nsp->[xopt,fopt,flag,lambda] = linprog_clp(p,zeros(0,N2),[],C,b,sense="min",Q=M);
-nsp->Qopt=zeros(N,N);
-nsp->for i=1:N,
==>  for j=1:N,
==>    Qopt(i,j)=xopt((i-1)*N+j)
==>  end;
==>end;
-nsp->copt=norm(Qopt*Y'-X')^2
copt	=		r (1x1)

 |  1.9609 |
-nsp->// Same problem using sparse representation
-nsp->if %f then 
==>  T=timer();
==>  N=200
==>  N2=N*N;
==>  X=grand(N,"mn",0,1);
==>  Y=grand(N,"mn",0,1.1);
==>  p=zeros(1,N2);
==>  M=sparse([],[],[N2,N2]);
==>  C=sparse([],[],[2*N,N2]);
==>  b=ones(2*N,1); 
==>  for i=1:N,
==>    for j=1:N,
==>      p((i-1)*N+j)=-X(i)*Y(j);
==>      C(i,(i-1)*N+j)=1;
==>      C(N+j,(i-1)*N+j)=1;
==>      for k=1:N,
==>	M((i-1)*N+j,(i-1)*N+k)=Y(j)*Y(k);
==>      end;
==>    end;
==>  end;
==>  p=p';
==>  [xopt,fopt,flag,lambda] = linprog_clp(p',sparse(zeros(0,N2)),[],C,b,sense="min",Q=M);
==>  T=timer()
==>  
==>  Qopt=zeros(N,N);
==>  for i=1:N,
==>    for j=1:N,
==>      Qopt(i,j)=xopt((i-1)*N+j)
==>    end;
==>  end;
==>  copt=norm(Qopt*Y'-X')^2
==>  fprintfMat("newX_1d.txt",Qopt*Y')
==>  fprintfMat("Y_1d.txt",Y')
==>  fprintfMat("X_1d.txt",X')
==>end
-nsp->// Compare to known solution
-nsp->newX= Y*Qopt';
-nsp->newX=sort(newX,dir='i');
-nsp->X=sort(X,dir='i');
-nsp->Y=sort(Y,dir='i' );
-nsp->wX=ones(1,length(X))*(1./length(X))
wX	=		r (1x10)

 |  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000 |
-nsp->wY=ones(1,length(Y))*(1./length(Y))
wY	=		r (1x10)

 |  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000 |
-nsp->p_m=X;w_m=wX;p_n=Y;w_n=wY;
-nsp->[L,VAL]=convex_hull_psi(p_m,w_m,p_n,w_n)
L	=		r (1x2)

 |       0  1.0000 |
VAL	=		r (1x2)

 |        0  -0.4428 |
-nsp->[pt_cw,w_cw]=curlywedge(X,wX,Y,wY)
pt_cw	=		r (1x10)

 |  -0.30320  -0.28622  -0.11511   0.05916   0.70754   1.07227   1.11284   1.25441   1.26958   1.38056 |
w_cw	=		r (1x10)

 |  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000 |
-nsp->[pt_cw,w_cw]=filter(pt_cw,w_cw)
pt_cw	=		r (1x10)

 |  -0.30320  -0.28622  -0.11511   0.05916   0.70754   1.07227   1.11284   1.25441   1.26958   1.38056 |
w_cw	=		r (1x10)

 |  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000  0.1000 |
-nsp->if %f then
==>  function y=phi(P,W,t)
==>    y=sum(W.*max(t-P,0.))
==>  endfunction
==>  // graphics 
==>  Npt=100
==>  a=-3.0
==>  b=3.0
==>  pas=(b-a)/Npt
==>  T= linspace(a,b,Npt);
==>  phi_nu= 1:Npt
==>  phi_mu=1:Npt
==>  phi_cw=1:Npt
==>  phi_CO=1:Npt
==>  for i = 1:Npt do
==>    phi_nu(i)=phi(Y,wY,T(i))
==>    phi_mu(i)=phi(X,wX,T(i))
==>    phi_cw(i)=phi(pt_cw,w_cw,T(i))
==>    phi_CO(i)=phi(newX,wX,T(i))    
==>  end
==>  hold('on');
==>  plot(T,phi_nu,'r');
==>  plot(T,phi_mu,'g')   
==>  plot(T,phi_CO,'b')
==>  plot(T,phi_cw,'m')
==>end
-nsp->w1=wasserstein(pt_cw,w_cw,X,wX,2);
-nsp->w2=wasserstein(newX,wX,X,wX,2);
-nsp->w3=wasserstein(pt_cw,w_cw,newX,wX,2);
-nsp->if abs(w1-w2) >= 1.e-5 then pause;end
-nsp->//printf("W2 curlywedge %f\n",wasserstein(pt_cw,w_cw,X,wX,2))
-nsp->//printf("W2 avec Coin-OR %f\n",wasserstein(newX,wX,X,wX,2))
-nsp->//printf("W2 curlywedge/Coin-OR %f\n",wasserstein(pt_cw,w_cw,newX,wX,2))
